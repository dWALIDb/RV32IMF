# RISC V
RISC V is an open Instruction Set Architecture used for the developement of custom processors.  
It is the **fifth** generation of developement hence, the V (in risv-V).  
The architecture is well documented by the RISC V organization, where the ISA is discussed.  
It has a base instruction set named RV32I containing all instructions necessary for a fully fledged 32-bit cental processing unit. It still
offers other extensions for more implementations depending on the manufacturers.  
  
In this implementation, 2 extensions are considered:  
**First**,the floating point extension (F) that provides a floating point register file, and instructions that handel floating point operands.  
**Second**,the integer multiply divide (M) that provides integer multiplication and division instructions.  

The naming convension specified in the *RISV V SPEC 2.2* specifies that using extensions requires using the letters corresponding to each extension with a specific ordering, hence, 
the top level of the design is named **RV32IMF**, it specifies that the CPU is 32-bit riscv soft core that provides base instructions, floating point instructions, and integer multiply 
devide instructions.  

# INTERNAL ARCHITECTURE  
The design is split into *five* stages to boost performance, and after implementation it turned out to be not as complicated as it seems.  
the stages are fetch,decode,execute,memory and write back.  

# FETCH STAGE
The module contains a RAM for instructions, a register that holds the program counter value and it outputs the instruction's op code, functionality fields, read/write addresses and 
immediate values. it always output PC+4 for next instruction.  
**NOTE THAT WE ADD 4 BECAUSE MEMORY IS LITTLE ENDIAN AND ALL INSTRUCTIONS ARE 32 BITS**  

# DECODE STAGE 
The module contains two 32x32 bit register files that are used for integer and floating point operations, the integer register file has the address *ZERO* as a hardwired zero that is 
very usefull, it also sign extends the encoded values in instructions that use immediate values.

# EXECUTE STAGE
The module handles all calculations and comparisons necessary for out instructions, it has three big modules that handle the majority of computations, namely arithmetic logic unit and 
multiply divide unit for integer operations and floating point unit for floating point operations, it calculates addresses depending on the different immediate fields generating by each 
format, finally it has comparators to generate flags used for conditional branch instructions that affect next instruction's address.

# MEMORY STAGE
The module contain the data ram that is used to store and load data and also set up the next incoming instruction depending on the flow of the program, **NORMALLY** the program counter 
gets the address of current instruction incremented by four, but due to some instructions the program counter may have different values such as an 12-bit offset, a totally different 
address or interrupt service routine address, for branches, control unit generates the desired flags and compares them to flags generated by the ALU, if they are equal the the branch 
address is taken, else we load the next instruction.  

# WRITE BACK STAGE 
This stage desides what data to write back to registers of the decode stage along with the address or it writes to the output register that may be used by the user.

# INTERRUPTS AND MY CUSTOM INSTRUCTIONS
Interrupts are not discussed widely in this ISA (at least i didn't find information) so i decided to design my own instructions for that.  

**INTERRUPT ENABLE INSTRUCTION:** it enables interrupt flag in control unit to accept interrupts, it is incoded as the JALR instruction but has different opcode. RD is used to store the 
address of the program counter of the interrupted instruction, RS1 and 12-bit immediate are used to generate the *INTERRUPT SERVICE ROUTINE* that is stored in MEMORY STAGE to be used 
uppon interrupting.  

If the internal interrupt flag is high and an interrupt is issued, it won't be acknowledged untill the instruction is executed and interrupt signal is still high, then the control unit 
enters the interrupt state where interrupt_acknoledged signal is high to enable the following :  
-PC recieves the interrupt service routine.  
-The interrupted instruction is stored in the register address specified in the interrupt enable instruction.  
-Internal interrupt flag is disabled.
After that the ISR is executed normally.  

**INTERRUPT DISABLE INSTRUCTION:** it disables interrupts so the signal will not affect the program flow.  

**INPUT DATA INSTRUCTION:** it is enoded as a load instruction but has different opcode and has source address1 as 0 because it reads user data into the ram.  

**OUTPUT DATA INSTRUCTION:** it is encoded as a store instruction but has different opcode and write address is 0 because it outputs data to the user.  
# RISC V ASSEMBLER 
The assembler is written in C++, the header file *"assembler_class"* provides the **assembler** class and the methods for converting 
assembly to machine code. The instruction can have no operands up to 3 operands, the following table explains all the instructions:
